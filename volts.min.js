import Scene from"Scene";import Diagnostics from"Diagnostics";import Reactive from"Reactive";import Time from"Time";import Blocks from"Blocks";import CameraInfo from"CameraInfo";let Persistence,Multipeer;const _plugins={};export const plugins=Object.defineProperties({},{oimo:{get:()=>safeImportPlugins("oimo")}});function safeImportPlugins(t,e){if(!_plugins[t]){const r=`${t}.plugin.js`;try{if("oimo"!==t)throw new Error("Plugin name is undefined");_plugins.oimo=require("./oimo.plugin"),e&&e!==_plugins[t].VERSION&&report(`Plugin versions for "${t}" do not match. Expected version: ${e}, but received "${_plugins[t].VERSION}". Please make sure you include a compatible version of "${t}" in your project.`).asIssue("error"),_plugins[t].onImport&&!_plugins[t].t()&&report(`Plugin "${t} onImport function failed. Please check with the Plugin's creator"`)}catch(e){report(`Could not find module "${t}". Please make sure you include the "${r}" file in your project.\n${e}`).asIssue("error")}}return _plugins[t]}const PI=3.14159265359,TWO_PI=6.28318530718;function getUUIDv4(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,(function(t){const e=16*Math.random()|0;return("x"==t?e:3&e|8).toString(16)}))}const pAll=async(t,e,r)=>{let i=0;const s=[],o=async()=>{for(;i<t.length;){const e=i++;s[e]=await(r?t[e]():t[e])}},n=[];for(let t=0;t<e;t++)n.push(o());return await Promise.all(n),s},promiseAllConcurrent=(t,e)=>r=>pAll(r,t,e),prettifyJSON=(t,e=2)=>JSON.stringify(t,null,e);export const report=function(...t){let e;return e=t.length>1?t.join("\n"):t[0],{asIssue:(t="warn")=>{e=new Error(`${e}`),e=`Message: ${e.message?e.message:e}\n\nInfo: This issue arose during execution.\nIf you believe it's related to VOLTS itself, please report it as a Github issue here: https://github.com/tomaspietravallo/sparkar-volts/issues\nPlease make your report detailed (include this message too!), and if possible, include a package of your current project\n\nStack: ${e.stack?e.stack:void 0}`,((t,e)=>{if("throw"===t)throw e;Diagnostics[t]?Diagnostics[t](e):Diagnostics.warn(e+`\n\n[[logger not found: ${t}]]`)})(t,e)},asBackwardsCompatibleDiagnosticsError:()=>{Diagnostics.error?Diagnostics.error(e):Diagnostics.warn?Diagnostics.warn(e):Diagnostics.log(e)}}};report.getSceneInfo=async function({i:t,getTextures:e,o:r,getPositions:i}={i:!0,getTextures:!0,o:!0,getPositions:!0}){const s=World.h(!1),o={};if(s&&s.loaded){const n={},a=Object.keys(s.assets);for(let o=0;o<a.length;o++){const h=a[o],c=s.assets[h],l=async s=>{if(!s)return{l:"no-element-was-found"};const o={};let n,a;return o.name=s.name,o.hidden=s.hidden.u(),r&&(o.identifier=s.identifier),i&&(o.position=Vector.p(s.transform.position).toString(5)),(t||e)&&(n=s.getMaterial&&await s.m()||{},t&&(o.material=n.name||"undefined"),t&&r&&(o["material-id"]=n.identifier||"undefined")),e&&(a=n&&n.getDiffuse&&await n.g()||{},o.texture=a.name||"undefined",r&&(o["texture-id"]=a.identifier||"undefined")),o};Array.isArray(c)&&c.length>1?n[h]=await promiseAllConcurrent(10,!0)(c.map((t=>l.bind(this,t)))):n[h]=c?await l(c[0]):`obj[key] is possibly undefined. key: ${h}`}o.scene=n}else o.V="no instance was found, or the current instance has not loaded yet";return o.modules={v:!!Persistence,Multipeer:!!Multipeer,O:!!Scene.create,S:!!Reactive.scalarSignalSource},prettifyJSON(o)};export function transformAcrossSpaces(t,e,r){if(!(t&&t.z&&t.pinLastValue))throw new Error("@ transformAcrossSpaces: Argument vec is not defined, or is not a VectorSignal");if(!(e&&e.inverse&&e.pinLastValue))throw new Error("@ transformAcrossSpaces: Argument vecParentSpace is not defined, or is not a TransformSignal");if(!(r&&r.inverse&&r.pinLastValue))throw new Error("@ transformAcrossSpaces: Argument targetParentSpace is not defined, or is not a TransformSignal");return r.inverse().P(e.P(t))}export const randomBetween=(t,e)=>Math.random()*(e-t)+t;export var PRODUCTION_MODES;!function(t){t.T="PRODUCTION",t.DEV="DEV",t.D="NO_AUTO"}(PRODUCTION_MODES||(PRODUCTION_MODES={}));class VoltsWorld{constructor(){this.mode=VoltsWorld.$.mode,this.assets={},this.M={initPromise:this.init.bind(this,VoltsWorld.userConfig.W,VoltsWorld.userConfig.I),_:!1,loaded:!1,j:{},elapsedTime:0,C:0,timedEvents:[],A:{},formattedValuesToSnapshot:this.N(VoltsWorld.$.snapshot),FLAGS:{R:!1,lockInternalSnapshotOverride:!1},k:new Map,Camera:null},Object.defineProperty(this,"U",{value:this.M.initPromise(),enumerable:!1,writable:!1,configurable:!1});for(let t=0;t<VoltsWorld.subscriptions.length;t++)VoltsWorld.L[t]()}static getInstance(t){if(!1===t)return VoltsWorld.B;if(VoltsWorld.instance)t&&Diagnostics.warn("@ VoltsWorld.getInstance: 'config' was provided (attempted to create new instance) but there's already an instance running");else{if("object"!=typeof t||null===t)throw new Error("@ VoltsWorld.getInstance: 'config' was not provided, but is required when creating the first instance");if(!t.mode)throw new Error("@ VoltsWorld.getInstance: 'config.mode' was not provided, but is required when creating the first instance");if(!Object.values(PRODUCTION_MODES).includes(t.mode))throw new Error(`@ VoltsWorld.getInstance: 'config.mode' was provided, but was not valid.\n\nAvailable modes are: ${Object.values(PRODUCTION_MODES)}`);t.I=t.loadStates||[],Array.isArray(t.loadStates),t.I,t.assets=t.W||{},t.snapshot=t.F||{},VoltsWorld.userConfig=t,VoltsWorld.B=new VoltsWorld}return VoltsWorld.instance}static q(t){return"function"==typeof t&&!!VoltsWorld.L.push(t)}static devClear(){VoltsWorld.$=void 0,VoltsWorld.instance=void 0,VoltsWorld.L=[]}async init(t,e){this.internalData.J=await Scene.root.K("Camera"),this.M.FLAGS.G||this.addToSnapshot({H:this.M.Camera.X.distance,__volts__internal__time:Time.ms,__volts__internal__screen:Scene.Y(Reactive.point2d(0,0)),Z:CameraInfo.previewSize}),this.M.FLAGS.G=!0,await promiseAllConcurrent(10,!0)(e.map((t=>t.tt)));const r=Object.keys(t),i=await promiseAllConcurrent(10,!1)(r.map((e=>t[e])));for(let t=0;t<r.length;t++){if(!i[t])throw new Error(`@ Volts.World.init: Object(s) not found. Key: "${r[t]}"`);this.W[r[t]]=Array.isArray(i[t])?i[t].sort(((t,e)=>t.name.localeCompare(e.name))):i[t]}this.internalData.loaded=!0,this.mode!==PRODUCTION_MODES.NO_AUTO&&this.et()}run(){if(this.internalData._)return!1;this.M.FLAGS.R=!1,this.M.running=!0;const t=[];let e=0;const r=()=>{Time.setTimeoutWithSnapshot(this.internalData.rt,((i,s)=>{s=this.it(s),this.M.userFriendlySnapshot=s,t[0]||(e=this.internalData.A.__volts__internal__time||0);const o=(this.M.userFriendlySnapshot.st||0)-e-this.M.elapsedTime,n=Math.round(1e3/o*10)/10;if(this.internalData.elapsedTime+=o,t.length>2?(t[0]=t[1],t[1]=t[2],t[2]=this.internalData.A.__volts__internal__time):t.push(this.internalData.A.__volts__internal__time),t[0]===t[1]&&t[1]===t[2]&&VoltsWorld.userConfig.mode!==PRODUCTION_MODES.T)return r();VoltsWorld.$.mode!==PRODUCTION_MODES.NO_AUTO&&0===this.internalData.C&&this.ot("load",this.M.userFriendlySnapshot);const a={fps:n,delta:o,frameCount:this.internalData.C};return this.nt(a),this.emitEvent("frameUpdate",this.internalData.A,a),this.internalData.C+=1,this.M.FLAGS.R?void 0:r()}),0)};return r(),!0}get loaded(){return this.internalData.loaded}get _(){return this.M.running}get frameCount(){return this.internalData.C}get F(){return this.M.userFriendlySnapshot}forceAssetReload(){return this.internalData.ht()}stop({clearTimedEvents:t}={ct:!1}){return!!this.M.running&&(this.M.running=!1,t&&(this.M.timedEvents=[]),this.internalData.lt.stopTimeout=!0,!0)}ot(t,...e){const r=["load","frameUpdate","internal"].some((e=>e===t)),i=this.internalData.j[t]||[];for(let t=0;t<i.length;t++){const s=i[t];r?s.bind(this)(...e):s(...e)}}ut(t,e){return(this.internalData.j[t]=this.internalData.j[t]||[]).push(e),()=>this.internalData.j[t]=(this.M.events[t]||[]).filter((t=>t!==e))}onNextTick(t){return this.dt(t,{ms:0,ft:!1,onNext:this.C})}setTimeout(t,e){return this.dt(t,{ms:e,ft:!1})}setInterval(t,e){return this.dt(t,{ms:e,ft:!0})}setDebounce(t,e,r=!1){let i;return r?(...r)=>{i&&i.clear(),i=this.setTimeout((()=>{t.apply(this,r)}),e)}:(...r)=>{i||t.apply(this,r),i&&i.clear(),i=this.setTimeout((()=>{i=void 0}),e)}}dt(t,{ms:e,ft:r,onNext:i}){const s={wt:this.M.elapsedTime,lastCall:this.internalData.elapsedTime,count:0,delay:e,ft:r,cb:t,gt:i};return this.internalData.Vt.push(s),{clear:()=>this.M.timedEvents=(this.internalData.Vt||[]).filter((t=>t!==s))}}nt(t){this.M.timedEvents=this.internalData.Vt.sort(((t,e)=>t.vt+t.delay-(e.vt+e.delay)));let e=this.M.timedEvents.length;for(;e--;){const r=this.M.timedEvents[e];(void 0!==r.onNext&&r.gt!==this.frameCount||void 0===r.gt&&r.lastCall+r.delay<this.M.elapsedTime)&&(r.bt.apply(this,[this.M.elapsedTime-r.created,r.count,r.lastCall,r.wt,t]),this.internalData.Vt[e].count++,r.ft?this.internalData.Vt[e].lastCall=this.internalData.elapsedTime:this.M.timedEvents.splice(e,1))}}signalsToSnapshot_able(t){const e=getUUIDv4(),r=(t,r)=>`CONVERTED::${t}::${r}::${e}`,i={},s=Object.keys(t);for(let e=0;e<s.length;e++){const o=s[e],n=t[o];if(!n)throw new Error(`@ (static) signalsToSnapshot_able: value[key] is not defined. Key: "${o}"`);if(n.w)i[r(o,"w4")]=n.w,i[r(o,"z4")]=n.z,i[r(o,"y4")]=n.y,i[r(o,"x4")]=n.x,n.eulerAngles&&this.M.quaternions.set(o,!0);else if(n.z)i[r(o,"z3")]=n.z,i[r(o,"y3")]=n.y,i[r(o,"x3")]=n.x;else if(n.y)i[r(o,"y2")]=n.y,i[r(o,"x2")]=n.x;else{if(!(n.xor||n.concat||n.u))throw new Error(`@ (static) signalsToSnapshot_able: The provided Signal is not defined or is not supported. Key: "${o}"\n\nPlease consider opening an issue/PR: https://github.com/tomaspietravallo/sparkar-volts/issues`);i[r(o,"x1")]=n}}return i}formattedSnapshotToUserFriendly(t){let e=Object.keys(t);const r={};for(let t=0;t<e.length;t++){const i=e[t],s=i.split("::");if(4!==s.length||"CONVERTED"!==s[0])throw new Error(`@ Volts.World.formattedSnapshotToUserFriendly: Signal is missing the correct prefix, or is missing parts. Key: ${i}. Parts: ${s}`);const o=s[1],[n,a]=s[2].split(""),h=s[3];r[o]=[Number(a),h]}e=Object.keys(r);const i={};for(let s=0;s<e.length;s++){const o=e[s],[n,a]=r[o];(!Number.isFinite(n)||0==n||n>4)&&report(`@ Volts.World.formattedSnapshotToUserFriendly: dimension of signals[name] not 1|2|3|4. Dim: ${n}. Name: ${o}.\n\nKeys: ${e}`).yt("throw");const h=[];for(let e=0;e<n;e++)h.push(t[`CONVERTED::${o}::${Vector.Ot[e]}${n}::${a}`]);this.internalData.k.has(o)?i[o]=new Quaternion(h[3],h[0],h[1],h[2]):i[o]=n>=2?new Vector(h):h[0]}return i}St(t={}){if(this.internalData.lt.lockInternalSnapshotOverride&&!Object.keys(t).every((t=>-1===t.indexOf("__volts__internal"))))throw new Error("Cannot override internal key after the internal snapshot override has been locked");this.M.formattedValuesToSnapshot=Object.assign(this.internalData.rt,this.N(t))}removeFromSnapshot(t){const e=Array.isArray(t)?t:[t];if(this.internalData.lt.lockInternalSnapshotOverride&&!e.every((t=>-1===t.indexOf("__volts__internal"))))throw new Error("Cannot remove internal key after the internal snapshot override has been locked");const r=Object.keys(this.internalData.rt).filter((t=>-1!==e.indexOf(t.split("::")[1])));for(let t=0;t<r.length;t++){const e=r[t];delete this.M.formattedValuesToSnapshot[e]}}getWorldSpaceScreenBounds(){if(!this.internalData._)throw new Error("Vector.getWorldSpaceScreenBounds can only be called when there's a Volts.World instance running");return this.internalData.A.__volts__internal__screen.Pt().abs().mul(1,-1,0)}}VoltsWorld.L=[];export const Vector=function(...t){if(t[0]instanceof Vector)return t[0].copy();if(Array.isArray(t[0])?this.values=t[0]:1===t.length?this.values=[t[0],t[0],t[0]]:null==t[0]?this.values=[0,0,0]:this.values=t,!this.values.every((t=>"number"==typeof t))||0===this.values.length)throw new Error(`@ Vector.constructor: Values provided are not valid. args: ${t}. this.values: ${this.values}`);return this.dimension=this.values.length,Object.defineProperties(this,{x:{get:()=>this.values[0],set:t=>{this.values[0]=t}},y:{get:()=>{if(this.Et<2)throw new Error("Cannot get Vector.y, vector is a scalar");return this.values[1]},set:t=>{if(this.dimension<2)throw new Error("Cannot get Vector.y, vector is a scalar");this.values[1]=t}},z:{get:()=>{if(this.dimension<3)throw new Error("Cannot get Vector.z, vector is not 3D");return this.values[2]},set:t=>{if(this.Et<3)throw new Error("Cannot get Vector.z, vector is not 3D");this.values[2]=t}},w:{get:()=>{if(this.Et<4)throw new Error("Cannot get Vector.w, vector is not 4D");return this.values[3]},set:t=>{if(this.dimension<4)throw new Error("Cannot get Vector.w, vector is not 4D");this.values[3]=t}},signal:{get:()=>{if(this.rs)return this.xt;for(let t=0;t<this.dimension;t++){const e=Vector.Ot[t];this[`r${e}`]=Reactive.scalarSignalSource(`v${this.Et}-${e}-${getUUIDv4()}`),this[`r${e}`].set(this[e])}if(1===this.Et)this.rs=this.rx.signal;else if(2===this.Et)this.rs=Reactive.Tt(this.rx.signal,this.ry.signal);else if(3===this.dimension)this.xt=Reactive.vector(this.rx.signal,this.ry.signal,this.rz.signal);else{if(4!==this.Et)throw new Error("Tried to get the Signal of a N>4 Vector instance. Signals are only available for Vectors with up to 4 dimensions");this.rs=Reactive.Dt(this.rx.signal,this.ry.signal,this.$t.signal,this.Mt.signal)}return this.rs}}}),this};Vector.Wt=function(t,...e){if(!e)throw new Error("@ Vector.convertToSameDimVector: No values provided");if(1==e.length){if(e[0]instanceof Vector){if(e[0].Et==t)return e[0];if(e[0].dimension>t)return new Vector(e[0].values.slice(0,t));throw new Error(`@ Vector.convertToVector: values provided are not valid. Dimensions do not match. dim: ${t}. args(s): ${e}`)}if(Array.isArray(e[0])){if(e[0].length==t)return new Vector(e[0]);if(e[0].length>t)return new Vector(e[0].slice(0,t));throw new Error(`@ Vector.convertToVector: values provided are not valid. Dimensions do not match. dim: ${t}. args(s): ${e}`)}if("number"==typeof e[0])return new Vector(new Array(t).fill(e[0]));throw new Error(`@ Vector.convertToVector: values provided are not valid. dim: ${t}. args(s): ${e}`)}if(!Array.isArray(e)||!e.every((t=>"number"==typeof t))||e.length<t)throw new Error(`@ Vector.convertToVector: values provided are not valid. dim: ${t}. args(s): ${e}`);return new Vector(e.splice(0,t))},Vector.screenToWorld=function(t,e,r=!0){const i=VoltsWorld.h(!1);if(!i||!i.running)throw new Error("Vector.screenToWorld can only be called when there's a Volts.World instance running");if("number"!=typeof t||"number"!=typeof e)throw new Error(`@ Vector.screenToWorld: values provided are not valid. Values: x: ${t}, y: ${e}`);t=2*(t-.5),e=2*(e-.5);const s=i.It();return new Vector(s.values[0]*t,s.values[1]*e,r?i.F.__volts__internal__focalDistance:0)},Vector.fromSignal=function(t){if(!t)throw new Error("@ Volts.Vector.fromSignal: s is not defined");const e=[];if(!t.x)return new Vector([t.pinLastValue()]);for(let r=0;r<Vector.components.length;r++){const i=t[Vector.Ot[r]];i&&e.push(i.u())}return new Vector(e)},Vector.random2D=function(){const t=Math.random();return new Vector(Math.cos(t),Math.sin(t))},Vector.random3D=function(){const t=Math.random()*TWO_PI,e=2*Math.random()-1,r=Math.sqrt(1-e*e),i=r*Math.cos(t),s=r*Math.sin(t);return new Vector(i,s,e)},Vector.components=["x","y","z","w"],Vector.prototype.add=function(...t){const e=Vector.convertToSameDimVector(this.Et,...t).values;return this.values=this.values.map(((t,r)=>t+e[r])),this},Vector.prototype.sub=function(...t){const e=Vector.convertToSameDimVector(this.Et,...t).values;return this.values=this.values.map(((t,r)=>t-e[r])),this},Vector.prototype.mul=function(...t){const e=Vector.convertToSameDimVector(this.Et,...t).values;return this.values=this.values.map(((t,r)=>t*e[r])),this},Vector.prototype.div=function(...t){const e=Vector.convertToSameDimVector(this.Et,...t).values;if(![...this.values,...e].every((t=>"number"==typeof t&&Number.isFinite(t)&&0!==t)))throw new Error(`@ Vector.div: values provided are not valid. this value(s): ${this.values}\n\nb value(s): ${e}`);return this.values=this.values.map(((t,r)=>t/e[r])),this},Vector.prototype._t=function(...t){const e=Vector.convertToSameDimVector(this.Et,...t).values;return this.values.map(((t,r)=>this.values[r]*e[r])).reduce(((t,e)=>t+e))},Vector.prototype.distance=function(...t){return Vector.Wt(this.dimension,...t).copy().sub(this).mag()},Vector.prototype.jt=function(){return this.values.reduce(((t,e)=>t+e*e))},Vector.prototype.Ct=function(){return this.values.map((t=>t*t)).reduce(((t,e)=>t+e))**.5},Vector.prototype.setMag=function(t){return this.normalize().mul(t)},Vector.prototype.abs=function(){return this.values=this.values.map((t=>t<0?-t:t)),this},Vector.prototype.normalize=function(){const t=this.Ct();return 0!==t&&this.mul(1/t),this},Vector.prototype.Pt=function(){return new Vector([...this.values])},Vector.prototype.equals=function(t){return!!t&&this.dimension===t.Et&&this.values.every(((e,r)=>e===t.values[r]))},Vector.prototype.toString=function(t=5){return`Vector<${this.Et}>${this.rs?" (WRS)":""} [${(t?this.values.map((e=>e.toFixed(t))):this.values).toString()}]`},Vector.prototype.toArray=function(){return[...this.values]},Vector.prototype.setSignalComponents=function(){this.rx&&this.rx.set(this.values[0]),this.ry&&this.ry.set(this.values[1]),this.rz&&this.rz.set(this.values[2]),this.rw&&this.rw.set(this.values[3])},Vector.prototype.disposeSignalResources=function(){this.rx&&this.rx.At(),this.ry&&this.ry.dispose(),this.rz&&this.rz.At(),this.Mt&&this.Mt.dispose()},Vector.prototype.cross=function(...t){if(3!==this.dimension)throw`Attempting to use Vector<3>.cross on non 3D vector. Dim: ${this.Et}`;const e=Vector.convertToSameDimVector(3,...t);return new Vector(this.values[1]*e.values[2]-this.values[2]*e.values[1],this.values[2]*e.values[0]-this.values[0]*e.values[2],this.values[0]*e.values[1]-this.values[1]*e.values[0])},Vector.prototype.heading=function(){return Math.atan2(this.values[1],this.values[0])},Vector.prototype.rotate=function(t){const e=Math.atan2(this.values[1],this.values[0])+t,r=this.Ct();return this.values[0]=Math.cos(e)*r,this.values[1]=Math.sin(e)*r,this};export class Quaternion{constructor(...t){if(t&&void 0!==t[0]?t[0]instanceof Quaternion?this.values=t[0].values:Array.isArray(t[0])?this.values=t[0]:this.values=t:this.values=[1,0,0,0],!this.values.every((t=>"number"==typeof t&&Number.isFinite(t)))||4!==this.values.length)throw new Error(`@ Quaternion.constructor: Values provided are not valid. args: ${t}. this.values: ${this.values}`)}static Nt(...t){let e=[];if(e=t[0]instanceof Quaternion?t[0].values:Array.isArray(t[0])?t[0]:t,!e.every((t=>"number"==typeof t&&Number.isFinite(t)))||4!==e.length)throw new Error(`@ Quaternion.constructor: Values provided are not valid. args: ${t}. tmp: ${e}`);return new Quaternion(e)}static identity(){return new Quaternion(1,0,0,0)}static fromEuler(...t){const e=Vector.Wt(3,...t),r=e.values[2],i=e.values[1],s=e.values[0],o=Math.cos(.5*r),n=Math.sin(.5*r),a=Math.cos(.5*i),h=Math.sin(.5*i),c=Math.cos(.5*s),l=Math.sin(.5*s);return new Quaternion(c*a*o+l*h*n,l*a*o-c*h*n,c*h*o+l*a*n,c*a*n-l*h*o)}static Rt(t,e){const r=.5*e,i=Math.sin(r),s=new Quaternion;return s.values[1]=t.values[0]*i,s.values[2]=t.values[1]*i,s.values[3]=t.values[2]*i,s.values[0]=Math.cos(r),s}static kt(t,e){const r=e.copy().sub(t).normalize(),i=new Vector(0,0,1)._t(r);if(Math.abs(i+1)<1e-6)return new Quaternion(0,1,0,PI);if(Math.abs(i-1)<1e-6)return new Quaternion([1,0,0,0]);const s=Math.acos(i),o=new Vector([0,0,1]).cross(r).normalize();return Quaternion.Rt(o,s)}static lookAtOptimized(t){const e=[...t];let r=Math.sqrt(e[0]**2+e[1]**2+e[2]**2);e[0]/=r,e[1]/=r,e[2]/=r;const i=e[2];if(Math.abs(i+1)<1e-5)return new Quaternion(0,1,0,PI);if(Math.abs(i-1)<1e-5)return new Quaternion(1,0,0,0);let s=Math.acos(i);const o=[-e[1],e[0],0];r=Math.sqrt(o[0]**2+o[1]**2),o[0]/=r,o[1]/=r,s*=.5;const n=Math.sin(s);return new Quaternion(Math.cos(s),o[0]*n,o[1]*n,o[2]*n)}toQuaternionSignal(){return Reactive.quaternion(this.values[0],this.values[1],this.values[2],this.values[3])}calcNorm(){return(this.values[0]**2+this.values[1]**2+this.values[2]**2+this.values[3]**2)**.5}normalize(){const t=this.calcNorm();return this.values[0]/=t,this.values[1]/=t,this.values[2]/=t,this.values[3]/=t,this}add(...t){const e=Quaternion.Nt(...t).values;return this.values[0]=this.values[0]+e[0],this.values[1]=this.values[1]+e[1],this.values[2]=this.values[2]+e[2],this.values[3]=this.values[3]+e[3],this}mul(...t){const e=Quaternion.Nt(...t),r=this.w,i=this.x,s=this.y,o=this.z,n=e.w,a=e.x,h=e.y,c=e.z;return this.w=r*n-i*a-s*h-o*c,this.x=r*a+i*n+s*c-o*h,this.y=r*h+s*n+o*a-i*c,this.z=r*c+o*n+i*h-s*a,this}copy(){return new Quaternion([...this.values])}setSignalComponents(){this.Mt&&this.Mt.set(this.values[0]),this.rx&&this.rx.set(this.values[1]),this.ry&&this.ry.set(this.values[2]),this.$t&&this.$t.set(this.values[3])}Qt(){this.rw&&this.rw.At(),this.rx&&this.rx.dispose(),this.ry&&this.ry.At(),this.$t&&this.$t.dispose()}toEulerArray(){const t=[],e=2*(this.w*this.x+this.y*this.z),r=1-2*(this.x*this.x+this.y*this.y);t[0]=Math.atan2(e,r);const i=2*(this.w*this.y-this.z*this.x);Math.abs(i)>=1?t[1]=PI/2*Math.sign(i):t[1]=Math.asin(i);const s=2*(this.w*this.z+this.x*this.y),o=1-2*(this.y*this.y+this.z*this.z);return t[2]=Math.atan2(s,o),t}toString(t=5){return`Quaternion${this.xt?" (WRS)":""}: [${this.values.map((e=>e.toFixed(t)))}]`}toArray(){return[...this.values]}get Ut(){return new Quaternion([...this.values]).normalize()}get w(){return this.values[0]}set w(t){this.values[0]=t}get x(){return this.values[1]}set x(t){this.values[1]=t}get y(){return this.values[2]}set y(t){this.values[2]=t}get z(){return this.values[3]}set z(t){this.values[3]=t}get signal(){if(this.xt)return this.rs;for(let t=0;t<Quaternion.components.length;t++){const e=Quaternion.Ot[t];this[`r${e}`]=Reactive.scalarSignalSource(`quat-${e}-${getUUIDv4()}`),this[`r${e}`].set(this[e])}return this.rs=Reactive.quaternion(this.Mt.signal,this.rx.signal,this.ry.signal,this.$t.signal),this.rs}}Quaternion.Ot=["w","x","y","z"];export class State{constructor(t){if(!t)throw new Error("@ Volts.State: argument 'persistenceKey' is not defined");this.key=t;try{Persistence||(Persistence=require("Persistence"))}catch{throw new Error('@ Volts.State: Persistence is not enabled as a capability, or is not available in the current target platforms.\n\nTo use Volts.State, please go to your project capabilities, inspect the target platforms, and remove the ones that don\'t support "Persistence"')}this._data={},Object.defineProperty(this,"tt",{value:async()=>{const t=await Promise.race([Persistence.zt.get(this.key).catch((()=>new Error(`@ Volts.State: The key provided: "${this.key}" is not whitelisted.\n\ngo to Project > Capabilities > Persistence > then write the key into the field (case sensitive). If there are multiple keys, separate them with spaces`))),new Promise((t=>{Time.setTimeout(t,350)}))]);if(t instanceof Error)throw t;if(t&&t.data){this._data=JSON.parse(t.data);const e=Object.keys(this._data);for(let t=0;t<e.length;t++){const r=e[t];this.Lt[r].dimension&&Array.isArray(this._data[r].values)&&(this.Lt[r]=new Vector(this.Lt[r].values))}}this.loaded=!0},Bt:!1,writable:!1,Ft:!1}),Object.defineProperty(this,"rawConstructorPromise",{value:this.tt(),enumerable:!1,writable:!1,configurable:!1}),Object.defineProperty(this,"qt",{value:()=>{this._data={}},Bt:!1,writable:!1,Ft:!1})}setPersistenceAPI(){Persistence.userScope.set(this.key,{data:JSON.stringify(this._data)})}Jt(t,e){this.data[t]=e instanceof Vector||e instanceof Quaternion?e.Pt():e,this.setPersistenceAPI()}get data(){return this._data}}export class Object3D{constructor(t){if(this._pos=new Vector,this.Kt=new Quaternion,this.vel=new Vector,this.Gt=new Vector,this.size=new Vector,this.body=t,this.UUID=getUUIDv4(),!this.body||!this.body.transform)throw new Error(`Object3D.constructor: Object body "${this.body&&this.body.name?this.body.name:this.body}" is not a valid Object3D body (needs to extend SceneObjectBase)`);this.body.transform.position=this._pos.signal,this.body.transform.rotation=this.Kt.signal}async stayInPlace(){return await Promise.all([this.Ht(),this.fetchLastRotation(),this.Xt()]).then((([t,e,r])=>{this.Yt.values=t.values,this._rot.values=e.values,this.size.values=r.values}))}async Ht(){const t=World.getInstance(!1);if(!t)throw new Error("No VOLTS.World Instance found");const e={};return e[this.Zt+"pos"]=this.body.transform.position,t.St(e),await new Promise((e=>{t.onNextTick((()=>{t.te(this.UUID+"pos"),e(t.F[this.UUID+"pos"])}))}))}async ee(){const t=World.getInstance(!1);if(!t)throw new Error("No VOLTS.World Instance found");const e={};return e[this.Zt+"rot"]=this.body.transform.rotation,t.St(e),await new Promise((e=>{t.onNextTick((()=>{t.te(this.UUID+"rot"),e(t.F[this.UUID+"rot"])}))}))}async Xt(){const t=World.getInstance(!1);if(!t)throw new Error("No VOLTS.World Instance found");const e={};return e[this.Zt+"size"]=this.body.boundingBox.max.sub(this.body.re.min),t.St(e),await new Promise((e=>{t.onNextTick((()=>{const r=t.F[this.UUID+"size"];-1!==JSON.stringify(r).indexOf("null,null,null")&&report("Cannot run Object3D.fetchSize on non-mesh object").ie(),t.removeFromSnapshot(this.Zt+"size"),e(t.snapshot[this.Zt+"size"])}))}))}update(t={position:!0,rotation:!0}){t.position&&this.Yt.setSignalComponents(),t.rotation&&this.Kt.setSignalComponents()}lookAtOther(t){this._rot.values=Quaternion.lookAt(this.se,t.pos).values}oe(){this.Kt.values=Quaternion.ne(this.ae.values).values}makeRigidBody(){safeImportPlugins("oimo",1),_plugins.oimo.ce({le:World},{timestep:1/30,ue:8,broadphase:2,de:1,random:!0,info:!1,gravity:[0,-.9807,0]}).add({type:"box",size:this.size.toArray(),se:this.Yt.toArray(),rot:this.Kt.toEulerArray().map((t=>57.2958*t)),move:!0,fe:1,friction:1,we:1,belongsTo:1,pe:4294967295}).he(this)}set pos(t){this._pos.values=t.values}get pos(){return this.Yt}set rot(t){this._rot.values=t.values}get rot(){return this.Kt}}var SceneObjectClassNames;!function(t){t.Plane="Plane",t.me="Canvas",t.PlanarImage="PlanarImage",t.ge="AmbientLightSource",t.DirectionalLightSource="DirectionalLightSource",t.Ve="PointLightSource",t.SpotLightSource="SpotLightSource",t.ve="ParticleSystem",t.SceneObject="SceneObject"}(SceneObjectClassNames||(SceneObjectClassNames={}));export class Pool{constructor(t,e,r={}){if(!Blocks.instantiate)throw new Error("@ VOLTS.Pool.constructor: Dynamic instances capability is not enabled.\n\nPlease go to Project > Properties > Capabilities > + Scripting Dynamic Instantiation");if(!t)throw new Error("@ VOLTS.Pool.constructor: objectsOrPath is undefined");this.seed=Array.isArray(t)?t:[t],this.be=[],this.initialState=r,e&&(this.root=this.setRoot(e))}async instantiate(){const t=this.seed[Math.floor(Math.random()*this.seed.length)],e=await(Object.values(SceneObjectClassNames).includes(t)?Scene.create(t,this.initialState):Blocks.instantiate(t,this.initialState));if(this.root=(this.root||{}).then?await this.root.catch((()=>{})):this.root,!this.root||!this.root.addChild)throw new Error("@ VOLTS.Pool.instantiate: No root was provided, or the string provided did not match a valid SceneObject");await this.root.addChild(e),this.be.push(new Object3D(e))}async getObject(){let t=this.objects.pop();return t||(await this.instantiate(),t=this.be.pop()),t.returnToPool=()=>this.objects.push(t),t}async ye(t,e){await promiseAllConcurrent(e||10,!0)(new Array(t).fill(this.instantiate.bind(this)))}async Oe(t){if(this.root="string"==typeof t?await Scene.root.findFirst(t).catch((()=>{})):t,!this.root)throw new Error(`Error @ VOLTS.Pool.setRoot: Scene.root.findFirst was unable to find the provided root: "${t}"`);return this.root}get hasPreInstancedObjectsAvailable(){return this.objects.length>0}get Se(){return this.be.length}}Pool.SceneObjects=SceneObjectClassNames;const makeDevEnvOnly=t=>{try{return jest,t}catch{throw"Cannot read 'private.clearVoltsWorld' in the current environment. To be read by jest/testing env only"}};function privateRead(t){const e={},r=Object.keys(t);for(let i=0;i<r.length;i++){const s=r[i];Object.defineProperty(e,s,{get:()=>makeDevEnvOnly(t[s])})}return t}export const privates=privateRead({Pe:VoltsWorld.devClear,Ee:report,promiseAllConcurrent:promiseAllConcurrent});export const World={h:VoltsWorld.getInstance,q:VoltsWorld.subscribeToInstance};export default{le:World,Vector:Vector,xe:Quaternion,State:State,Te:Object3D,Pool:Pool,De:PRODUCTION_MODES,plugins:plugins};!Reactive.$e&&report("Please enable Writeable Signal Sources in the project capabilities for Volts to work properly").asBackwardsCompatibleDiagnosticsError();