import Scene from"Scene";import Diagnostics from"Diagnostics";import Reactive from"Reactive";import Time from"Time";let Persistence;function getUUIDv4(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(t){const e=16*Math.random()|0;return("x"==t?e:3&e|8).toString(16)})}const prettifyJSON=(t,e=2)=>JSON.stringify(t,null,e);export const report=function(...t){let e;return e=t.length>1?t.join("\n"):t[0],{asIssue:(n="warn")=>{((t,e)=>{if("throw"===t)throw e;Diagnostics[t]?Diagnostics[t](e):Diagnostics.warn(e+`\n\n[[logger not found: ${t}]]`)})(n,e=`Message: ${(e=new Error(`${t}`)).message?e.message:e}\n\n.Info: This issue arose during execution.\nIf you believe it's related to VOLTS itself, please report it as a Github issue here: https://github.com/tomaspietravallo/sparkar-volts/issues\nPlease make your report detailed (include this message too!), and if possible, include a package of your current project\n\nStack: ${e.stack?e.stack:void 0}`)}}};report.getSceneInfo=async function({getMaterial:t,getTexture:e,getIdentifiers:n,getPosition:r}={getMaterial:!0,getTexture:!0,getIdentifiers:!0,getPosition:!0}){const s=World.getInstance(!1);let a;if(s&&s.loaded){const i={},o=Object.keys(s.assets);for(let a=0;a<o.length;a++){const l=o[a],c=s.assets[l],u=async s=>{const a={};let i,o;return a.name=s.name,n&&(a.identifier=s.identifier),r&&(a.position=Vector.fromSignal(s.transform.position).toString(5)),(t||e)&&(i=s.getMaterial&&await s.getMaterial()||{},t&&(a.material=i.name||"undefined"),n&&(a["material-id"]=i.identifier||"undefined")),e&&(o=i&&i.getDiffuse&&await i.getDiffuse()||{},a.texture=o.name||"undefined",n&&(a["texture-id"]=o.identifier||"undefined")),a};Array.isArray(c)&&c.length>1?i[l]=await Promise.all(c.map(t=>u(t))):i[l]=c?await u(c[0]):`obj[key] is possibly undefined. key: ${l}`}a=prettifyJSON(i)}else a="no instance was found, or the current instance has not loaded yet";return a};export function transformAcrossSpaces(t,e,n){if(!(t&&t.z&&t.pinLastValue))throw new Error("@ transformAcrossSpaces: Argument vec is not defined, or is not a VectorSignal");if(!(e&&e.inverse&&e.pinLastValue))throw new Error("@ transformAcrossSpaces: Argument vecParentSpace is not defined, or is not a TransformSignal");if(!(n&&n.inverse&&n.pinLastValue))throw new Error("@ transformAcrossSpaces: Argument targetParentSpace is not defined, or is not a TransformSignal");return n.inverse().applyToPoint(e.applyToPoint(t))}export var PRODUCTION_MODES;!function(t){t.PRODUCTION="PRODUCTION",t.DEV="DEV",t.NO_AUTO="NO_AUTO"}(PRODUCTION_MODES||(PRODUCTION_MODES={}));class VoltsWorld{constructor(){this.mode=VoltsWorld.userConfig.mode,this.assets={},this.internalData={initPromise:this.init.bind(this,VoltsWorld.userConfig.assets,VoltsWorld.userConfig.loadStates),running:!1,loaded:!1,events:{},elapsedTime:0,frameCount:0,timedEvents:[],userFriendlySnapshot:{},formattedValuesToSnapshot:this.signalsToSnapshot_able(VoltsWorld.userConfig.snapshot),FLAGS:{stopTimeout:!1,lockInternalSnapshotOverride:!1},Camera:null},Object.defineProperty(this,"rawInitPromise",{value:this.internalData.initPromise(),enumerable:!1,writable:!1,configurable:!1})}static getInstance(t){if(!1===t)return VoltsWorld.instance;if(VoltsWorld.instance)t&&Diagnostics.warn("@ VoltsWorld.getInstance: 'config' was provided (attempted to create new instance) but there's already an instance running");else{if("object"!=typeof t||null===t)throw new Error("@ VoltsWorld.getInstance: 'config' was not provided, but is required when creating the first instance");if(!t.mode)throw new Error("@ VoltsWorld.getInstance: 'config.mode' was not provided, but is required when creating the first instance");if(!Object.values(PRODUCTION_MODES).includes(t.mode))throw new Error(`@ VoltsWorld.getInstance: 'config.mode' was provided, but was not valid.\n\nAvailable modes are: ${Object.values(PRODUCTION_MODES)}`);t.loadStates=t.loadStates||[],Array.isArray(t.loadStates),t.loadStates,t.assets=t.assets||{},t.snapshot=t.snapshot||{},VoltsWorld.userConfig=t,VoltsWorld.instance=new VoltsWorld}return VoltsWorld.instance}static devClear(){VoltsWorld.getInstance(!1);VoltsWorld.userConfig=void 0,VoltsWorld.instance=void 0}async init(t,e){this.internalData.Camera=await Scene.root.findFirst("Camera"),this.addToSnapshot({__volts__internal__focalDistance:this.internalData.Camera.focalPlane.distance,__volts__internal__time:Time.ms,__volts__internal__screen:Scene.unprojectToFocalPlane(Reactive.point2d(0,0))}),this.internalData.FLAGS.lockInternalSnapshotOverride=!0;await Promise.all(e.map(t=>t.loadState()));const n=Object.keys(t),r=await Promise.all([...n.map(e=>t[e])]);for(let t=0;t<n.length;t++){if(!r[t])throw new Error(`@ Volts.World.init: Object(s) not found. Key: "${n[t]}"`);this.assets[n[t]]=(Array.isArray(r[t])?r[t]:[r[t]]).sort((t,e)=>t.name.localeCompare(e.name))}this.internalData.loaded=!0,this.mode!==PRODUCTION_MODES.NO_AUTO&&this.run()}run(){if(this.internalData.running)return!1;this.internalData.running=!0;const t=[];let e=0;const n=()=>{Time.setTimeoutWithSnapshot(this.internalData.formattedValuesToSnapshot,(r,s)=>{s=this.formattedSnapshotToUserFriendly(s),this.internalData.userFriendlySnapshot=s,t[0]||(e=this.internalData.userFriendlySnapshot.__volts__internal__time||0);const a=(this.internalData.userFriendlySnapshot.__volts__internal__time||0)-e-this.internalData.elapsedTime,i=Math.round(1e3/a*10)/10;if(this.internalData.elapsedTime+=a,t.length>2?(t[0]=t[1],t[1]=t[2],t[2]=this.internalData.userFriendlySnapshot.__volts__internal__time):t.push(this.internalData.userFriendlySnapshot.__volts__internal__time),t[0]===t[1]&&t[1]===t[2]&&this.mode!==PRODUCTION_MODES.PRODUCTION)return n();this.mode!==PRODUCTION_MODES.NO_AUTO&&0===this.internalData.frameCount&&this.emitEvent("load",this.internalData.userFriendlySnapshot);const o={fps:i,delta:a,frameCount:this.internalData.frameCount};return this.runTimedEvents(o),this.emitEvent("frameUpdate",this.internalData.userFriendlySnapshot,o),this.internalData.frameCount+=1,this.internalData.FLAGS.stopTimeout?void 0:n()},0)};return n(),!0}get loaded(){return this.internalData.loaded}get running(){return this.internalData.running}get frameCount(){return this.internalData.frameCount}get snapshot(){return this.internalData.userFriendlySnapshot}forceAssetReload(){return this.internalData.initPromise()}stop({clearTimedEvents:t=!1}={clearTimedEvents:!1}){return!!this.internalData.running&&(this.internalData.running=!1,t&&(this.internalData.timedEvents=[]),this.internalData.FLAGS.stopTimeout=!0,!0)}emitEvent(t,...e){["load","frameUpdate","testing"].some(e=>e===t)?(this.internalData.events[t]||[]).forEach(t=>t.bind(this)(...e)):(this.internalData.events[t]||[]).forEach(t=>t(...e))}onEvent(t,e){return(this.internalData.events[t]=this.internalData.events[t]||[]).push(e),()=>this.internalData.events[t]=(this.internalData.events[t]||[]).filter(t=>t!==e)}setTimeout(t,e){return this.setTimedEvent(t,e,!1)}setInterval(t,e){return this.setTimedEvent(t,e,!0)}setDebounce(t,e,n=!1){let r;return n?(...n)=>{r&&r.clear(),r=this.setTimeout(()=>{t.apply(this,n)},e)}:(...n)=>{r||t.apply(this,n),r&&r.clear(),r=this.setTimeout(()=>{r=void 0},e)}}setTimedEvent(t,e,n){const r={created:this.internalData.elapsedTime,lastCall:this.internalData.elapsedTime,count:0,delay:e,recurring:n,cb:t};return this.internalData.timedEvents.push(r),{clear:()=>this.internalData.timedEvents=(this.internalData.timedEvents||[]).filter(t=>t!==r)}}runTimedEvents(t){this.internalData.timedEvents=this.internalData.timedEvents.sort((t,e)=>t.lastCall+t.delay-(e.lastCall+e.delay));let e=this.internalData.timedEvents.length;for(;e--;){const n=this.internalData.timedEvents[e];n.lastCall+n.delay<this.internalData.elapsedTime&&(n.cb.apply(this,[this.internalData.elapsedTime-n.created,n.count,n.lastCall,n.created,t]),this.internalData.timedEvents[e].count++,n.recurring?this.internalData.timedEvents[e].lastCall=this.internalData.elapsedTime:this.internalData.timedEvents.splice(e,1))}}signalsToSnapshot_able(t){const e=getUUIDv4(),n=(t,n)=>`CONVERTED::${t}::${n}::${e}`,r={},s=Object.keys(t);for(let e=0;e<s.length;e++){const a=s[e],i=t[a];if(!i)throw new Error(`@ (static) signalsToSnapshot_able: value[key] is not defined. Key: "${a}"`);if(i.w)r[n(a,"W4")]=i.w,r[n(a,"Z4")]=i.z,r[n(a,"Y4")]=i.y,r[n(a,"X4")]=i.x;else if(i.z)r[n(a,"Z3")]=i.z,r[n(a,"Y3")]=i.y,r[n(a,"X3")]=i.x;else if(i.y)r[n(a,"Y2")]=i.y,r[n(a,"X2")]=i.x;else{if(!(i.xor||i.concat||i.pinLastValue))throw new Error(`@ (static) signalsToSnapshot_able: The provided Signal is not defined or is not supported. Key: "${a}"\n\nPlease consider opening an issue/PR: https://github.com/tomaspietravallo/sparkar-volts/issues`);r[n(a,"X1")]=i}}return r}formattedSnapshotToUserFriendly(t){let e=Object.keys(t);const n={};for(let t=0;t<e.length;t++){const r=e[t],s=r.split("::");if(4!==s.length||"CONVERTED"!==s[0])throw new Error(`@ Volts.World.formattedSnapshotToUserFriendly: Signal is missing the correct prefix, or is missing parts. Key: ${r}. Parts: ${s}`);const a=s[1],[i,o]=s[2].split(""),l=s[3];n[a]=[Number(o),l]}e=Object.keys(n);const r={};for(let s=0;s<e.length;s++){const a=e[s],[i,o]=n[a];if(!Number.isFinite(i)||0==i||i>4)throw new Error(`@ Volts.World.formattedSnapshotToUserFriendly: dimension of signals[name] not 1|2|3|4. Dim: ${i}. Name: ${a}.\n\nPlease report this on Github as an issue\n\nExtra data:\nKeys: ${e}`);const l=[],c=["X","Y","Z","W"];for(let e=0;e<i;e++)l.push(t[`CONVERTED::${a}::${c[e]}${i}::${o}`]);r[a]=i>=2?new Vector(l):l[0]}return r}addToSnapshot(t){this.internalData.formattedValuesToSnapshot=Object.assign(this.internalData.formattedValuesToSnapshot,this.signalsToSnapshot_able(t))}removeFromSnapshot(t){const e=Array.isArray(t)?t:[t],n=Object.keys(this.internalData.formattedValuesToSnapshot).filter(t=>-1!==e.indexOf(t.split("::")[1]));for(let t=0;t<n.length;t++){const e=n[t];delete this.internalData.formattedValuesToSnapshot[e]}}getWorldSpaceScreenBounds(){return this.internalData.userFriendlySnapshot.__volts__internal__screen.copy().abs().mul(1,-1,0)}}export const Vector=function(...t){if(t[0]instanceof Vector)return t[0].copy();if(Array.isArray(t[0])?this.values=t[0]:1===t.length?this.values=[t[0],t[0],t[0]]:t[0]?this.values=t:this.values=[0,0,0],!this.values.every(t=>"number"==typeof t)||0===this.values.length)throw new Error(`@ Vector.constructor: Values provided are not valid. args: ${t}. this.values: ${this.values}`);return this.dimension=this.values.length,Object.defineProperties(this,{x:{get:()=>this.values[0],set:t=>{this.values[0]=t}},y:{get:()=>{if(this.dimension<2)throw new Error("Cannot get Vector.y, vector is a scalar");return this.values[1]},set:t=>{if(this.dimension<2)throw new Error("Cannot get Vector.y, vector is a scalar");this.values[1]=t}},z:{get:()=>{if(this.dimension<3)throw new Error("Cannot get Vector.z, vector is not 3D");return this.values[2]},set:t=>{if(this.dimension<3)throw new Error("Cannot get Vector.z, vector is not 3D");this.values[2]=t}},w:{get:()=>{if(this.dimension<4)throw new Error("Cannot get Vector.w, vector is not 4D");return this.values[3]},set:t=>{if(this.dimension<4)throw new Error("Cannot get Vector.w, vector is not 4D");this.values[3]=t}}}),this};Vector.convertToSameDimVector=function(t,...e){if(!e)throw new Error("@ Vector.convertToSameDimVector: No values provided");if(1==e.length){if(e[0]instanceof Vector){if(e[0].dimension==t)return e[0];if(e[0].dimension>t)return new Vector(e[0].values.slice(0,t));throw new Error(`@ Vector.convertToVector: values provided are not valid. Dimensions do not match. dim: ${t}. args(s): ${e}`)}if(Array.isArray(e[0])){if(e[0].length==t)return new Vector(e[0]);if(e[0].length>t)return new Vector(e[0].slice(0,t));throw new Error(`@ Vector.convertToVector: values provided are not valid. Dimensions do not match. dim: ${t}. args(s): ${e}`)}if("number"==typeof e[0])return new Vector(new Array(t).fill(e[0]));throw new Error(`@ Vector.convertToVector: values provided are not valid. dim: ${t}. args(s): ${e}`)}if(!Array.isArray(e)||!e.every(t=>"number"==typeof t)||e.length<t)throw new Error(`@ Vector.convertToVector: values provided are not valid. dim: ${t}. args(s): ${e}`);return new Vector(e.splice(0,t))},Vector.screenToWorld=function(t,e,n=!0){const r=VoltsWorld.getInstance(!1);if(!r||!r.running)throw new Error("Vector.screenToWorld can only be called when there's a Volts.World instance running");if("number"!=typeof t||"number"!=typeof e)throw new Error(`@ Vector.screenToWorld: values provided are not valid. Values: x: ${t}, y: ${e}`);t=2*(t-.5),e=2*(e-.5);const s=r.getWorldSpaceScreenBounds();return new Vector(s.values[0]*t,s.values[1]*e,n?r.snapshot.__volts__internal__focalDistance:0)},Vector.fromSignal=function(t){if(!t)throw new Error("@ Volts.Vector.fromSignal: s is not defined");const e=[],n=["x","y","z","w"];if(!t.x)return new Vector([t.pinLastValue()]);for(let r=0;r<n.length;r++){const s=t[n[r]];s&&e.push(s.pinLastValue())}return new Vector(e)},Vector.prototype.add=function(...t){const e=Vector.convertToSameDimVector(this.dimension,...t).values;return this.values=this.values.map((t,n)=>t+e[n]),this},Vector.prototype.sub=function(...t){const e=Vector.convertToSameDimVector(this.dimension,...t).values;return this.values=this.values.map((t,n)=>t-e[n]),this},Vector.prototype.mul=function(...t){const e=Vector.convertToSameDimVector(this.dimension,...t).values;return this.values=this.values.map((t,n)=>t*e[n]),this},Vector.prototype.div=function(...t){const e=Vector.convertToSameDimVector(this.dimension,...t).values;if(![...this.values,...e].every(t=>"number"==typeof t&&Number.isFinite(t)&&0!==t))throw new Error(`@ Vector.div: values provided are not valid. this value(s): ${this.values}\n\nb value(s): ${e}`);return this.values=this.values.map((t,n)=>t/e[n]),this},Vector.prototype.dot=function(...t){const e=Vector.convertToSameDimVector(this.dimension,...t).values;return this.values.map((t,n)=>this.values[n]*e[n]).reduce((t,e)=>t+e)},Vector.prototype.distance=function(...t){return Vector.convertToSameDimVector(this.dimension,...t).copy().sub(this).mag()},Vector.prototype.magSq=function(){return this.values.reduce((t,e)=>t+e*e)},Vector.prototype.mag=function(){return this.values.map(t=>t*t).reduce((t,e)=>t+e)**.5},Vector.prototype.abs=function(){return this.values=this.values.map(t=>t<0?-t:t),this},Vector.prototype.normalize=function(){const t=this.mag();return 0!==t&&this.mul(1/t),this},Vector.prototype.copy=function(){return new Vector(this.values)},Vector.prototype.equals=function(t){return!!t&&this.dimension===t.dimension&&this.values.every((e,n)=>e===t.values[n])},Vector.prototype.toString=function(t){return`Vector<${this.dimension}> [${(t?this.values.map(e=>e.toFixed(t)):this.values).toString()}]`},Vector.prototype.cross=function(...t){if(3!==this.dimension)throw`Attempting to use Vector<3>.cross on non 3D vector. Dim: ${this.dimension}`;const e=Vector.convertToSameDimVector(3,...t);return new Vector(this.values[1]*e.values[2]-this.values[2]*e.values[1],this.values[2]*e.values[0]-this.values[0]*e.values[2],this.values[0]*e.values[1]-this.values[1]*e.values[0])},Vector.prototype.heading=function(){return Math.atan2(this.values[1],this.values[0])},Vector.prototype.rotate=function(t){const e=Math.atan2(this.values[1],this.values[0])+t,n=this.mag();return this.values[0]=Math.cos(e)*n,this.values[1]=Math.sin(e)*n,this};export class Quaternion{constructor(...t){t&&t[0]?t[0]instanceof Quaternion?this.values=t[0].values:Array.isArray(t[0])?this.values=t[0]:this.values=t:this.values=[0,0,0,1]}static convertToQuaternion(...t){let e=[];if(!(e=t[0]instanceof Quaternion?t[0].values:Array.isArray(t[0])?t[0]:t).every(t=>"number"==typeof t&&Number.isFinite(t))||4!==e.length)throw new Error(`@ Vector.constructor: Values provided are not valid. args: ${t}. tmp: ${e}`);return new Quaternion(e)}static identity(){return new Quaternion(0,0,0,1)}toQuaternionSignal(){return Reactive.quaternion(this.values[0],this.values[1],this.values[2],this.values[3])}calcNorm(){return(this.values[0]**2+this.values[1]**2+this.values[2]**2+this.values[3]**2)**.5}normalize(){const t=this.calcNorm();return this.values[0]/=t,this.values[1]/=t,this.values[2]/=t,this.values[3]/=t,this}add(...t){const e=Quaternion.convertToQuaternion(...t).values;return this.values=this.values.map((t,n)=>t+e[n]),this}copy(){return new Quaternion(this.values)}get normalized(){return new Quaternion(this.values).normalize()}get w(){return this.values[0]}set w(t){this.values[0]=t}get x(){return this.values[1]}set x(t){this.values[1]=t}get y(){return this.values[2]}set y(t){this.values[2]=t}get z(){return this.values[3]}set z(t){this.values[3]=t}}export class State{constructor(t){if(!t)throw new Error("@ Volts.State: argument 'persistenceKey' is not defined");this.key=t;try{Persistence||(Persistence=require("Persistence"))}catch{throw new Error('@ Volts.State: Persistence is not enabled as a capability, or is not available in the current target platforms.\n\nTo use Volts.State, please go to your project capabilities, inspect the target platforms, and remove the ones that don\'t support "Persistence"')}this._data={},Object.defineProperty(this,"loadState",{value:async()=>{const t=await Promise.race([Persistence.userScope.get(this.key).catch(()=>new Error(`@ Volts.State: The key provided: "${this.key}" is not whitelisted.\n\ngo to Project > Capabilities > Persistence > then write the key into the field (case sensitive). If there are multiple keys, separate them with spaces`)),new Promise(t=>{Time.setTimeout(t,350)})]);if(t instanceof Error)throw t;if(t&&t.data){this._data=JSON.parse(t.data);const e=Object.keys(this._data);for(let t=0;t<e.length;t++){const n=e[t];this._data[n].dimension&&Array.isArray(this._data[n].values)&&(this._data[n]=new Vector(this._data[n].values))}}this.loaded=!0},enumerable:!1,writable:!1,configurable:!1}),Object.defineProperty(this,"rawConstructorPromise",{value:this.loadState(),enumerable:!1,writable:!1,configurable:!1}),Object.defineProperty(this,"wipe",{value:()=>{this._data={}},enumerable:!1,writable:!1,configurable:!1})}setPersistenceAPI(){Persistence.userScope.set(this.key,{data:JSON.stringify(this._data)})}setKey(t,e){this.data[t]=e instanceof Vector?e.copy():e,this.setPersistenceAPI()}get data(){return this._data}}export const privates={clearVoltsWorld:()=>{try{return jest,VoltsWorld.devClear()}catch{throw"Cannot read 'private.clearVoltsWorld' in the current environment. To be read by jest/testing env only"}},getReport:()=>{try{return jest,report}catch{throw"Cannot read 'private.getReport' in the current environment. To be read by jest/testing env only"}}};export const World={getInstance:VoltsWorld.getInstance};export default{World:World,Vector:Vector,Quaternion:Quaternion,State:State,PRODUCTION_MODES:PRODUCTION_MODES};